+ 数据的基本单位是数据元素；

+ 一个数据元素由若干个数据项组成，数据项是数据的不可分割最小单位

+ 数据对象是性质相同的数据元素的集合

+ 数据结构是相互之间存在一种或多种特定关系的数据元素的集合

+ + 物理结构：在计算机的表示（储存结构）
  + 逻辑结构：数据结构中的关系
  + 逻辑结构对应一种物理结构是错的

+ $O(1) <O(\log_2 n) < O(n) < O(n \log_2 n ) < O(n^2) < O(n^3) <O(2^n) < O(3^n) < O(n!)$

+ 顺序存储结构的优缺点

   + 优点

     + 逻辑相邻，物理相邻

     + 可随机存取任一元素

     + 存储空间使用紧凑

   + 缺点
     + 插入、删除操作需要移动大量的元素
  + 预先分配空间需按最大空间分配，利用不充分
     + 表容量难以扩充

+ 广义表的表头与表尾

+ 判断有向图是否有回路：拓扑排序

+ 线性表La和Lb表示两个集合，现要求两集合的并，并存放在线性表La中 <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211211183210676.png" alt="image-20211211183210676" style="zoom: 80%;" /><img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211211194957608.png" alt="image-20211211194957608" style="zoom:80%;" />

+ 普里姆算法和克鲁斯卡尔算法是两种利用最小生成树性质构造最小生成树的算法，其中**前者与边数无关，适合边稠密的网，后者与前者相反，适合边稀疏的网。**

+ 在散列表中，**装填因子越大**，则插入记录时**发生冲突的可能性越大**   

+ 线性表、栈与队列的异同点

   + 相同点：都是线性结构，都是逻辑结构的概念。都可以用顺序存储或链表存储；栈和队列是两种特殊的线性表，即受限的线性表，只是对插入、删除运算加以限制。 
   + 不同点：运算规则不同，线性表为随机存取，而栈是只允许在一端进行插入、删除运算，因而是后进先出表LIFO；队列是只允许在一端进行插入、另一端进行删除运算，因而是先进先出表FIFO。 

+ 栈的约束条件：

+ 队列的约束条件

   |          | 空队                 | 入队                                              | 出队                                              |
   | -------- | -------------------- | ------------------------------------------------- | ------------------------------------------------- |
   | 链队列   | $front== rear$       | $q= rear->next;\\rear = q;$                       | $front= front->next;$                             |
   | 顺序队列 | $front== rear$       | $ sq[rear++]=x;$                                  | $x=sq[front++];$                                  |
   | 循环队列 | $ front==rear$       | $ rear=(rear+1)\%M;\\  sq[rear]=x;$               | $front=(front+1)\%M;\\x=sq[front];$               |
   | 改进     | $ front==rear$       | $Q.base[Q.rear] = e;\\    Q.rear = (Q.rear+1)\%M$ | $e = Q.base[Q.front];\\Q.front = (Q.front+1)\% M$ |
   |          | $(rear+1)\%M==front$ |                                                   |                                                   |

+ 循环队列

  + 把队列设想成环形，让sq[0]接在 sq[M-1]之后，若rear==M, 则令rear=0;
    重复利用已经用过的空间
  + + 入队：$ rear=(rear+1)\%M;   sq[rear]=x;$
    + 出队: $front=(front+1)\%M;    x=sq[front];$
  + + 队空：$front==rear$
    + 队满：$front==rear$    or      $(rear+1)\%M==front$(少用一个元素空间)
    + 一个循环队列Q的存储空间大小为M， 其队头和队尾分别为$front和rear$，则循环队列中元素的个数为： $ (rear-front+M)\%M     $
  
+ 简述线性结构和非线性结构的不同

+ <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211211200040446.png" alt="image-20211211200040446" style="zoom: 67%;" />

+ 森林、树与二叉树的转化

   + 树转换为二叉树：
     + 加线：在兄弟之间加一连线
     + 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系
     + 旋转：以树的根结点为轴心，将整树顺时针转45°
     + <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211207111918840.png" alt="image-20211207111918840" style="zoom:50%;" />
   + 二叉树转换为树：
     + 加线：若p结点是双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，……沿分支找到的所有右孩子，都与p的双亲用线连起来
     + 抹线：抹掉原二叉树中双亲与右孩子之间的连线
     + 调整：将结点按层次排列，形成树结构
     + <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211207112018838.png" alt="image-20211207112018838" style="zoom: 50%;" />

   + 森林转换为二叉树：
     + 将各棵树分别转换成二叉树
     + 将每棵树的根结点用线相连
     + 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构
     + <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211207112130104.png" alt="image-20211207112130104" style="zoom: 50%;" />

   + 二叉树转换为森林：
     + 抹线：将二叉树中根结点与其右孩子连线，及沿右分支搜索到的所有右孩子间连线全部抹掉,使之变成孤立的二叉树
     + 还原：将孤立的二叉树还原成树
     + <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211207112241726.png" alt="image-20211207112241726" style="zoom: 50%;" />

+ 适于对动态查找表进行高效率查找的组织结构是(  C  )。

   A．有序表    B．分块有序表  C．二叉排序树 D．线性链表

+ 由两个栈共享一个顺序存储空间的好处是：节省存储空间，降低**上溢**发生的机率

+ +  **设某棵二叉树中度数为0的结点数为$N_0$，度数为1的结点数为$N_1$，则该二叉树中度数为2的结点数为_$N_0-1$_；**
  + 若采用二叉链表作为该二叉树的存储结构，则该二叉树中共有__$2N_0+N_1$__个空指针域。
  + **具有n个结点的完全二叉树的深度为$\lfloor log_2 n \rfloor +1$**
  + 在n个结点的二叉链表中，有n+1个空指针域

+ **AOV网：有向无回路的图------拓扑排序**

  **AOE网：带权有向无环图------关键路径**

+ 在一个链队列中，假定front和rear分别为队首和队尾指针，则删除一个结点的操作为__A__。

   $A．front=front->next  　 B．rear=rear->next$

   $C．rear=front->next   　D．front=rear->next$

+ 快排的比较次数

   + 最优：每趟分为两个长度相等的序列

     如：7个分为3,3，则$a_7 = a_3 +a_3 + 6$

   + 最差：顺序或逆序最差：$1+2+3+...+n = n(n-1)/2$

+ 三元组线性表的行与列从0开始

+ 线索链表中的$rtag$域值为__1__时，表示该结点无右孩子，此时 $RChild $域为指向该结点后继线索的指针。

+ 假定对长度n=50的有序表进行折半查找，则对应的判定树高度为_6_，最后一层的结点数为_19_。

   + 折半查找成功与不成功与关键字比较的次数不会超过$\lfloor log_2 n \rfloor +1$
   + $ASL = \log_2 (n+1) -1$

+ 假定一个顺序表的长度为40，并假定查找每个元素的概率都相同，则在查找成功情况下的平均查找长度**20.5**,在查找不成功情况下的平均查找长度**41**

+ 评价一个算法通常从**正确性、可读性、健壮性和效率与低存储量需求**等方面考察。其中我们通常用**时间复杂度**度量算法的效率。

+ <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211207100815702.png" alt="image-20211207100815702" style="zoom:80%;" />

+ **简单排序包括除希尔排序之外的所有插入排序，起泡排序和简单选择排序,**以直接插入排序为最简单，当序列中的记录“基本有序”或n值较小时，它是最佳的排序方法，因此常将它和其它的排序方法结合在一起使用。

+ **从方法的稳定性来比较，基数排序是稳定的内排序方法**，所有时间复杂度为O(n^2)的简单排序法也是稳定的，然而，快速排序、堆排序和希尔排序等时间性能较好的排序方法都是不稳定的。

+ + 快排的最好情况：每次总是选到中间值作枢轴

  + 快排的最坏情况：每次总是选到最小或最大元素作枢轴

+ **从平均时间性能而言，快速排序最佳，其所需时间最省**，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后两者相比较的结果是，在n较大时，归并排序所需时间较堆排序省，但它所需的辅助存储量最多。

+ 直接插入排序的第一趟结果是：认为第一个元素为有序

  但是由于前n-1个有序之后第n个自然有序，则比较n-1次即可有序

+ 强连通图：**有向图中**，如果对每一对$V_i,V_j \in V，V_i \neq V_j，从V_i到V_j和从V_j到 V_i$都存在路径，则称G是~

+ 设散列表中有 m 个存储单元，散列函数 H(key)= key % p ，则 p 最好选择**小于等于m的最大素数**
  + 严蔚敏《数据结构》：一般情况下，可以**选p为质数**或不包含小于20的质因数的合数。

+ 完全二叉树

  + 有n个结点，则有$\lceil n/2 \rceil$个叶子结点
  + 含有**n个叶子结点**的完全二叉树的深度为  $\lceil \log_2 n \rceil +1$  
  + 含有**n个结点**的完全二叉树的深度为  $\lfloor \log_2 n \rfloor +1$  
  + 建立堆时，取最后一个非叶子结点，取第$\lfloor n/2 \rfloor$个节点
  + <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211207213442687.png" alt="image-20211207213442687" style="zoom: 80%;" />

+ 邻接矩阵非链接的边是0

  在最小生成树prim算法建立矩阵时非连接的边为无穷大

  最短路径是也是 无穷

+ 逆邻接表：有向图中对**每个结点建立以Vi为头的弧的单链表**<img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211207214555268.png" alt="image-20211207214555268" style="zoom:67%;" />

+ 有关图算法的时间复杂度：
  
  + 无向图：n个顶点，e条边
    + 邻接矩阵进行深度与广度遍历：$T(n)=O(n^2)$
    + 邻接表进行遍历：$T(n) = O(n+e)$
  
  + 最小生成树：
    + 普利姆算法：$T(n)=O(n^2)$
    + 克鲁斯卡尔方法：$T(n)= O(E\log E)$
  + 拓扑排序：$T(n) = O(n+e)$
  + 关键路径：
  + 最短路径：
    + 一个顶点—迪杰斯特拉(Dijkstra)算法：$T(n)=O(n^2)$
    + 每一对顶点：
      + 遍历地杰斯特拉算法：$T(n)=O(n^3)$
      + 弗洛伊德(Floyd)算法：$T(n)=O(n^3)$

+ 注意到：带权无向图的最小生成树不是惟一的

+ 哈夫曼树没有度数为1的结点

+ <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211208103126718.png" alt="image-20211208103126718" style="zoom:67%;" />



