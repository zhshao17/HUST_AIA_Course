# 11 贪心算法

+ 某种意义上的**局部最优选择，但希望最终达到全局最优**
+ 在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似

## 11.1 概念

## 11.2 算法结构性质

### 11.2.1 最优子结构性质

+ 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。
+ **该问题可用动态规划算法或贪心算法求解的关键特征。**

### 11.2.2 贪心选择性质

+ 所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到
+ 贪心算法与动态规划算法的**主要区别**：
  + **动态规划算法通常以自底向上的方式解各子问题**；
  + **贪心算法则通常以自顶向下的方式进行**，以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题**简化为规模更小的子问题**

## 11.3 贪心算法——动态规划算法

+ 共同点：贪心算法和动态规划算法都要求问题具有最优子结构性质

+ 实例1. 0-1背包问题**(不可用贪心算法)**

  + 直接或间接地给定n种物品和一个背包。物品i的重量是W_i，其价值为V_i，背包的容量为C。 应如何选择装入背包的物品，使得装入背包中物品的总价值最大?
    限制：在选择装入背包的物品时，**对每种物品i只有2种选择，即装入背包或不装入背包**。不能将物品i装入背包多次，也不能只装入物品i的一部分。
  + 算法选择分析：
    + 贪心选择之所以不能得到最优解是因为在这种情况下，**它无法保证最终能将背包装满**，部分闲置的背包空间使每公斤背包空间的价值降低了。
    + **在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择**。由此就导出许多**互相重叠的子问题**。这正是该问题可用动态规划算法求解的另一重要特征。
    + 动态规划算法的确可以有效地解0-1背包问题。
  
+ 实例2. 背包问题：**(可用贪心算法)**

  + 直接或间接地给定n种物品和一个背包。物品i的重量是W_i，其价值为V_i，背包的容量为C。应如何选择装入背包的物品，使得装入背包中物品的总价值最大?
     限制：**可以选择物品 i 的一部分，而不一定要全部装入背包**，$1\leq i\leq n$
     
  + + 计算每种物品**单位重量的价值  Vi / Wi**；
     + 依贪心选择策略，将**尽可能多的**单位重量价值最高的物品装入背包；
     + 若将**这种物品全部装入背包后**，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能多地装入背包；
     + 依此策略一直地进行下去，直到背包装满为止。
    
  + 算法：
  
    ```c
    void Knapsack(int n,float M,float v[],float w[],float x[]){
           Sort(n,v,w); //将各种物品依其单位重量的价值从大到小排序
           int i;
           for (i=1;i<=n;i++) x[i]=0;
           float c=M;
           for (i=1;i<=n;i++) {
              if (w[i]>c) break;
              x[i]=1;
              c-=w[i];
              }
           if (i<=n) x[i]=c/w[i];
          //如果有剩余空间，就将i物品的部分装入。
    }
    ```
## 11.4 贪心算法实例

### 11.4.1 活动安排问题

+ 设有n个活动的集合$E={1,2,…,n}$，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。
  每个活动 $i$ 都有一个要求使用该资源的起始时间$s_i$和一个结束时间$f_i$,且$s_i < f_i $
  如果选择了活动$i$，则它在半开时间区间$[s_i, f_i) $内占用资源
  若区间$[s_i, f_i)$与区间$[s_j, f_j)$不相交，则称活动 $i $与活动$ j $是相容的，即，当 $s_i ≥ f_j 或 s_i ≥ f_i$时，活动i与活动j相容

+ 目标：选择最多的互不冲突的活动，使相容活动集合最大找最大相容子集合

+ 算法 GreedySelector :
```C
template<class Type>
void GreedySelector(int n, Type s[], Type f[], bool  A[])
{
       A[1]=true;
       int j=1;
       for (int i=2;i<=n;i++) {
          if (s[i]>=f[j]) { A[i]=true; j=i; }
          else A[i]=false;
          }
}
```
+ 算法的分析：
  + 由于输入的活动按照其完成时间的非减序排列，所以算法greedySelector每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动
  + 算法greedySelector的效率极高
    + 当输入的活动已按结束时间的非减序排列，算法只需O(n)的时间安排n个活动，使最多的活动能相容地使用公共资源
    + 如果所给出的活动未按非减序排列，可以用$O(n \log n)$的时间重排

+ 实例：<img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211203150944588.png" alt="image-20211203150944588" style="zoom:50%;" />                     <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211203151002037.png" alt="image-20211203151002037" style="zoom:50%;" />        

### 11.4.2 最优装载问题

+ 有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为W_i。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船

```c
template<class Type>
void Loading(int x[],  Type w[], Type c, int n)
{
        int *t = new int [n+1];
        Sort(w, t, n); // t(i)=物品i的排序序号,按重量的升序排序
        for (int i = 1; i <= n; i++) x[i] = 0;
        for (int i = 1; i <= n && w[t[i]] <= c; i++) 
        {  
           x[t[i]] = 1; c -= w[t[i]]; 
        }
}
```

+ 性质：<img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211203145850467.png" alt="image-20211203145850467" style="zoom: 67%;" />

### 11.4.3 单源最短路径

+ 给定一个图G=(V, E)，其上的边权函数w为非负数。给定V中的一个顶点，称为源。现在要计算从源到所有其它各顶点的最短路长度。这里路的长度是指路上各边权之和。这个问题通常称为单源最短路径问题。
+ 算法步骤：**Dijkstra贪心算法**
  + **初始时，S中仅含有源**
  + 设u是G 的某一个顶点，**把从源到u且中间只经过S 中顶点的路称为从源到u的特殊路径**，并用数组dist记录当前每个顶点所对应的最短特殊路径长度
  + 每次从V-S中取出**具有最短特殊路长度的顶点u，将u添加到S中，同时对数组dist作必要的修改**
  + 一旦S包含了所有V中顶点，dist就记录了从源到所有其它顶点之间的最短路径长度

+ <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211203150151522.png" alt="image-20211203150151522" style="zoom:67%;" />

+ 复杂性：
  + 对于具有**n**个顶点和**e**条边的带权有向图，如果用带权邻接矩阵表示这个图，那么**Dijkstra**算法的主循环体需要**O(n)**时间。这个循环需要执行**n-1**次，所以完成循环需要$O(n)$时间。算法的其余部分所需要时间不超过$O(n^2)$
  + <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211203150306493.png" alt="image-20211203150306493" style="zoom:50%;" />

### 11.4.4 多机调度问题

+ 要求给出一种作业调度方案，使所给的n个作业在尽可能短的时间内由m台机器加工处理完成。
+ 解决思路：采用**最长处理时间作业优先的贪心选择策略**设计较好的**近似算法。**
  + 当 $n\leq m$时，只要将机器 i的$[0, t_i]$时间区间分配给作业 i即可，算法只需要$O(1)$时间
  + 当 $n>m$时，首先将**n个作业依其所需的处理时间从大到小排序**，然后依此顺序将作业分配给空闲的处理机
  + 算法所需的计算时间为$O(n \log n)$。

+ <img src="C:\Users\Asus\AppData\Roaming\Typora\typora-user-images\image-20211203150614048.png" alt="image-20211203150614048" style="zoom:67%;" />

